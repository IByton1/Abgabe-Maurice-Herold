1.  Bit operations can be useful for working with sets because they allow you to perform set operations (union, intersection, difference, etc.) using bitwise operations, which can be faster than using the built-in set operations.


2.  An arithmetic right shift (also called a signed right shift) preserves the sign of the number by filling the leftmost bits with copies of the original leftmost bit. This means that if the number is negative, the leftmost bit will always be 1 after the shift, and the number will remain negative.

    On the other hand, a logical right shift (also called an unsigned right shift) fills the leftmost bits with 0s, regardless of the sign of the number. This means that a logical right shift will always shift the bits towards more positive values, regardless of whether the original number was negative or positive.


3.  The expression n & (n-1) performs a bitwise AND operation between n and n-1.
    If n is a power of 2, then n is a single 1 bit followed by zero or more 0 bits. For example, 8 (1000 in binary) is a power of 2.
    When n-1 is calculated, the rightmost 1 bit is flipped to 0 and all the 0 bits on the right become 1s. For example, 7 (0111 in binary) is 8-1.
    When n and n-1 are ANDed together, the result is 0. For example, 8 & 7 is 1000 & 0111, which is 0000.


4.  Initialize a counter to 0.
    Create a mask with the value 1 and left-shift it by 0 to start.
    Use a loop to iterate over the bits of the integer.
    In each iteration, check if the AND of the integer and the mask is greater than 0. If it is, increment the counter.
    Left-shift the mask by 1 in each iteration.
    Continue looping until the mask is greater than the integer.
    The final value of the counter is the number of bits set to 1.